---
import Text from "@/elements/Text.astro";
import Visual from "./_Visual/_Visual.astro";
---

<section class="container">
  <div class="inner">
    <div class="content">
      <h1 class="title">
        Hi, I am <br />
        <span class="title-strong">Astlanox</span>.
      </h1>
      <p class="role">Web developer</p>
      <Text>
        Frontend-focused web developer with a strong UI / UX background, bridging design and development to build
        modern, scalable websites, focused on clarity, usability, and long-term maintainability.
      </Text>
    </div>

    <Visual />
  </div>

  <canvas id="blob3d" class="blob3d" aria-hidden="true"></canvas>
</section>

<style lang="scss">
  @use "@/styles/tokens" as *;
  @use "@/styles/utilities" as *;

  .blob3d {
    position: fixed;
    inset: 0;
    top: 50%;
    left: 50%;
    z-index: -1;
    width: 100%;
    height: 75%;
    transform: translate(-50%, -50%);

    @include up(medium) {
      height: 90%;
    }
  }

  .container {
    @include container;
    @include box;

    position: relative;
    justify-content: center;
    text-align: center;
  }

  .inner {
    @include inner;
    @include box(xlarge);

    @include up(xlarge) {
      @include box(xxxlarge);
    }
  }

  .content {
    @include box;
    @include container-inner;
  }

  .title {
    background: t(text, gradient);
    background-clip: text;
    -webkit-text-fill-color: transparent;

    @include title(primary, xxlarge);

    &-strong {
      @include title(primary, xxxlarge, uppercase);
    }
  }

  .role {
    @include title(accent, medium, uppercase);

    &::before {
      content: "ROLE: ";
    }
  }
</style>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";

  const CONFIG = {
    renderer: {
      alpha: true,
      antialias: true,
      powerPreference: "high-performance",
      pixelRatioCap: 2,
      clearColor: 0x000000,
      clearAlpha: 0,
    },
    camera: { fov: 45, near: 0.1, far: 100, position: [0, 0, 6] },
    lights: {
      ambient: { color: 0xffffff, intensity: 0.25 },
      directional: { color: 0xffffff, intensity: 0.85, position: [2, 2, 3] },
    },
    geometry: { radius: 2.05, detail: 20 },
    motion: { timeScale: 0.2, rotY: 0.1, rotX: 0.05, reducedMotionMedia: "(prefers-reduced-motion: reduce)" },
    look: {
      gradient: { left: "#5379EC", right: "#D339DE", softness: 1 },
      mark: { color: "#cfd7ff", opacity: 0.05, size: 0.12, thickness: 1, boost: 1 },
      fill: { opacity: 0.3, haloStrength: 0.42 },
      deform: { disp: 0.22 },
      alphaClampMax: 0.3,
      grad: { radiusTuned: 2.2, noiseAmp: 0.04, noiseFreqY: 12.0, noiseSpeed: 0.6 },
      silhouette: {
        rimPow: 1.7,
        fresPow: 2.1,
        edgeSmoothA: 0.78,
        edgeSmoothB: 1.05,
        fillFeatherAtten: 0.8,
        alphaFeatherStrength: 0.8,
      },
      shade: { fillMixA: 0.78, fillMixB: 0.22, postMulA: 0.92, postMulB: 0.08 },
    },
  };

  const canvas = getCanvas("#blob3d");

  const renderer = createRenderer(canvas, CONFIG.renderer);

  const scene = new THREE.Scene();

  const camera = createCamera(CONFIG.camera);
  addLights(scene, CONFIG.lights);

  const geometry = createBaryIcoSphere(CONFIG.geometry.radius, CONFIG.geometry.detail);

  const material = createBlobMaterial(CONFIG.look);

  const mesh = new THREE.Mesh(geometry, material);
  material.depthWrite = false;
  scene.add(mesh);

  const resize = createResizer(canvas, renderer, camera);
  new ResizeObserver(resize).observe(canvas);
  resize();

  const prefersReduced = window.matchMedia(CONFIG.motion.reducedMotionMedia).matches;

  const clock = new THREE.Clock();

  if (prefersReduced) {
    material.uniforms.uTime.value = 0;
    renderer.render(scene, camera);
  } else {
    const tick = () => {
      const t = clock.getElapsedTime();

      const ts = t * CONFIG.motion.timeScale;

      material.uniforms.uTime.value = ts;
      mesh.rotation.y = ts * CONFIG.motion.rotY;
      mesh.rotation.x = ts * CONFIG.motion.rotX;

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    };
    tick();
  }

  function getCanvas(selector) {
    const el = document.querySelector(selector);
    if (!(el instanceof HTMLCanvasElement)) {
      throw new Error(`Canvas element "${selector}" not found`);
    }
    return el;
  }

  function createRenderer(canvasEl, opts) {
    const r = new THREE.WebGLRenderer({
      canvas: canvasEl,
      alpha: opts.alpha,
      antialias: opts.antialias,
      powerPreference: opts.powerPreference,
    });
    r.setPixelRatio(Math.min(window.devicePixelRatio || 1, opts.pixelRatioCap));
    r.setClearColor(opts.clearColor, opts.clearAlpha);
    return r;
  }

  function createCamera(opts) {
    const c = new THREE.PerspectiveCamera(opts.fov, 1, opts.near, opts.far);
    c.position.set(...opts.position);
    return c;
  }

  function addLights(sceneEl, opts) {
    sceneEl.add(new THREE.AmbientLight(opts.ambient.color, opts.ambient.intensity));

    const d = new THREE.DirectionalLight(opts.directional.color, opts.directional.intensity);
    d.position.set(...opts.directional.position);
    sceneEl.add(d);
  }

  function createResizer(canvasEl, rendererEl, cameraEl) {
    return () => {
      const w = canvasEl.clientWidth || 1;

      const h = canvasEl.clientHeight || 1;
      rendererEl.setSize(w, h, false);
      cameraEl.aspect = w / h;
      cameraEl.updateProjectionMatrix();
    };
  }

  function createBaryIcoSphere(radius, detail) {
    const base = new THREE.IcosahedronGeometry(radius, detail);

    const geo = base.toNonIndexed();

    const vCount = geo.attributes.position.count;

    const bary = new Float32Array(vCount * 3);
    for (let i = 0; i < vCount; i += 3) {
      bary.set([1, 0, 0, 0, 1, 0, 0, 0, 1], i * 3);
    }
    geo.setAttribute("aBary", new THREE.BufferAttribute(bary, 3));
    return geo;
  }

  function createBlobMaterial(look) {
    return new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      uniforms: {
        uTime: { value: 0 },
        uLeft: { value: new THREE.Color(look.gradient.left) },
        uRight: { value: new THREE.Color(look.gradient.right) },
        uMark: { value: new THREE.Color(look.mark.color) },
        uFillAlpha: { value: look.fill.opacity },
        uMarkAlpha: { value: look.mark.opacity },
        uNodeWidth: { value: look.mark.thickness },
        uNodeLen: { value: look.mark.size },
        uCrossBoost: { value: look.mark.boost },
        uHaloStrength: { value: look.fill.haloStrength },
        uGradSoftness: { value: look.gradient.softness },
        uDisp: { value: look.deform.disp },
        uAlphaMax: { value: look.alphaClampMax },
        uRadiusTuned: { value: look.grad.radiusTuned },
        uNoiseAmp: { value: look.grad.noiseAmp },
        uNoiseFreqY: { value: look.grad.noiseFreqY },
        uNoiseSpeed: { value: look.grad.noiseSpeed },
        uRimPow: { value: look.silhouette.rimPow },
        uFresPow: { value: look.silhouette.fresPow },
        uEdgeA: { value: look.silhouette.edgeSmoothA },
        uEdgeB: { value: look.silhouette.edgeSmoothB },
        uFillMixA: { value: look.shade.fillMixA },
        uFillMixB: { value: look.shade.fillMixB },
        uPostMulA: { value: look.shade.postMulA },
        uPostMulB: { value: look.shade.postMulB },
        uAlphaFeatherStrength: { value: look.silhouette.alphaFeatherStrength },
      },
      vertexShader: `
        uniform float uTime;
        uniform float uDisp;

        attribute vec3 aBary;

        varying vec3 vBary;
        varying vec3 vNormalW;
        varying vec3 vPosW;

        float n3(vec3 p){
          return
            0.55*sin(p.x*1.7 + uTime*1.25) +
            0.35*sin(p.y*2.1 + uTime*1.65) +
            0.25*sin(p.z*2.7 + uTime*1.05) +
            0.15*sin((p.x+p.y+p.z)*3.1 + uTime*1.95);
        }

        void main(){
          vBary = aBary;

          vec3 n = normalize(normal);
          float nval = n3(position * 0.9);
          vec3 pos = position + n * (nval * uDisp);

          vec4 worldPos = modelMatrix * vec4(pos, 1.0);
          vPosW = worldPos.xyz;
          vNormalW = normalize(mat3(modelMatrix) * n);

          gl_Position = projectionMatrix * viewMatrix * worldPos;
        }
      `,
      fragmentShader: `
        uniform vec3 uLeft;
        uniform vec3 uRight;
        uniform vec3 uMark;

        uniform float uTime;
        uniform float uFillAlpha;
        uniform float uMarkAlpha;

        uniform float uNodeWidth;
        uniform float uNodeLen;

        uniform float uCrossBoost;
        uniform float uHaloStrength;

        uniform float uGradSoftness;

        uniform float uAlphaMax;
        uniform float uRadiusTuned;
        uniform float uNoiseAmp;
        uniform float uNoiseFreqY;
        uniform float uNoiseSpeed;

        uniform float uRimPow;
        uniform float uFresPow;
        uniform float uEdgeA;
        uniform float uEdgeB;

        uniform float uFillMixA;
        uniform float uFillMixB;

        uniform float uPostMulA;
        uniform float uPostMulB;

        uniform float uAlphaFeatherStrength;

        varying vec3 vBary;
        varying vec3 vNormalW;
        varying vec3 vPosW;

        float edgeLine(float b){
          float w = fwidth(b) * uNodeWidth;
          return 1.0 - smoothstep(0.0, w, b);
        }

        float vertexMark(vec3 bary){
          float x = bary.x;
          float y = bary.y;
          float z = bary.z;

          float nearA = smoothstep(1.0 - uNodeLen, 1.0, x);
          float nearB = smoothstep(1.0 - uNodeLen, 1.0, y);
          float nearC = smoothstep(1.0 - uNodeLen, 1.0, z);

          float markA = nearA * max(edgeLine(y), edgeLine(z));
          float markB = nearB * max(edgeLine(z), edgeLine(x));
          float markC = nearC * max(edgeLine(x), edgeLine(y));

          return max(markA, max(markB, markC));
        }

        void main(){
          vec3 N = normalize(vNormalW);
          vec3 V = normalize(cameraPosition - vPosW);

          float gs = max(0.0, uGradSoftness);
          float noise = sin(vPosW.y * uNoiseFreqY + uTime * uNoiseSpeed) * uNoiseAmp;
          float g = smoothstep(-uRadiusTuned - gs, uRadiusTuned + gs, vPosW.x + noise);
          vec3 baseCol = mix(uLeft, uRight, g);

          float fres = pow(1.0 - max(0.0, dot(N, V)), uFresPow);
          float mark = vertexMark(vBary);

          float rim = pow(1.0 - max(0.0, dot(N, V)), uRimPow);
          float r = length(vPosW) / uRadiusTuned;
          float edge = smoothstep(uEdgeA, uEdgeB, r);
          float feather = max(rim, edge);

          vec3 fill = baseCol * (uFillMixA + uFillMixB * fres);
          vec3 halo = baseCol * (uHaloStrength * feather);
          vec3 fillCol = fill + halo;

          vec3 finalCol = fillCol + uMark * (mark * uCrossBoost);
          finalCol *= (uPostMulA + uPostMulB * (1.0 - fres));

          float alphaFill = uFillAlpha * (1.0 - uAlphaFeatherStrength * feather);
          float alpha = alphaFill + (uMarkAlpha * mark);

          gl_FragColor = vec4(finalCol, clamp(alpha, 0.0, uAlphaMax));
        }
      `,
    });
  }
</script>
